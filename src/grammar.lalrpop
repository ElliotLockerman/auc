
use std::collections::HashMap;

use std::str::FromStr;
use ast;


grammar;


pub Float: f64 = <r#"-?(0|[1-9][0-9]*)(\.([0-9]+))?([eE]([-+]?[0-9]+))?"#> => f64::from_str(<>).unwrap();

pub UnitName: String = <r#"[a-zA-Z_]+"#> => <>.to_string();

pub Unit: (String, i32) = {
    <UnitName> => (<>, 1),
    <n:UnitName> "^" <f:Float> => (n, f as i32),
};



pub Num: ast::Num = {
    <Float> => ast::Num{val: <>, units: HashMap::new()},
    <Unit+> => ast::Num{val:1.0, units: <>.iter().cloned().collect()},
    <f:Float> <u:Unit+> => ast::Num{val:f, units: u.iter().cloned().collect()},
}


pub Exp: ast::Expression = {
    <e:Exp> "+" <t:T> => ast::Expression::Sum(Box::new(e), Box::new(t)),
    <e:Exp> "-" <t:T> => ast::Expression::Diff(Box::new(e), Box::new(t)),
    T => ast::Expression::Term(Box::new(<>)),
}


pub T: ast::Term = {
    <t:T> "*" <f:Fact> => ast::Term::Prod(Box::new(t), Box::new(f)),
    <t:T> "/" <f:Fact> => ast::Term::Quot(Box::new(t), Box::new(f)),
    Fact => ast::Term::Factor(Box::new(<>)),
}

pub Fact: ast::Factor = {
    Num => ast::Factor::Num(<>),
    // <n1:Num> "^" <n2:Num> => ast::Factor::Num(n1.pow(n2)),
    // <n:Num> "^" "(" <e:Exp> ")" => ast::Factor::NPowE(n, Box::new(e)),
    "(" <e:Exp> ")" => ast::Factor::Exp(Box::new(e)),
    "(" <e1:Exp> ")" "^" <n:Num> => ast::Factor::EPowN(Box::new(e1), n),
    "(" <e1:Exp> ")" "^" "(" <e2:Exp> ")" => ast::Factor::EPowE(Box::new(e1), Box::new(e2)),
}




